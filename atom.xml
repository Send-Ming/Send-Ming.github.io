<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我不明智</title>
  
  <subtitle>二流程序员的博客</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-09-26T11:20:44.537Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Send-Ming</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2022年 扬州(第二个省赛拿铜牌不是很满意)</title>
    <link href="http://example.com/2022/09/26/2022JSCPC%E9%92%9D%E8%A7%92%E6%B8%B8%E5%B9%BF%E9%99%B5/"/>
    <id>http://example.com/2022/09/26/2022JSCPC%E9%92%9D%E8%A7%92%E6%B8%B8%E5%B9%BF%E9%99%B5/</id>
    <published>2022-09-26T11:16:50.980Z</published>
    <updated>2022-09-26T11:20:44.537Z</updated>
    
    <content type="html"><![CDATA[<p>虽然但是 瘦西湖真的很好看哎</p><span id="more"></span><p><img src="https://cdn.acwing.com/media/article/image/2022/09/26/69408_9f17c57c3d-04C4E5C4C23E5A545CCC8DE066371D22.jpg" alt="04C4E5C4C23E5A545CCC8DE066371D22.jpg"><br><img src="https://cdn.acwing.com/media/article/image/2022/09/26/69408_39a6de253d-2E600E1EC71DFAE4A7477E721F632A7B.jpg" alt="2E600E1EC71DFAE4A7477E721F632A7B.jpg"><br><img src="https://cdn.acwing.com/media/article/image/2022/09/26/69408_3d5174063d-07FC85B091779F85040638B6441CCEE5.jpg" alt="07FC85B091779F85040638B6441CCEE5.jpg"><br><img src="https://cdn.acwing.com/media/article/image/2022/09/26/69408_407779363d-20EA370E12103AC5FBC9C669FF319DF0.jpg" alt="20EA370E12103AC5FBC9C669FF319DF0.jpg"><br><img src="https://cdn.acwing.com/media/article/image/2022/09/26/69408_432e8a103d-77053737591137477B8ED97F1D15DDC8.jpg" alt="77053737591137477B8ED97F1D15DDC8.jpg"><br><img src="https://cdn.acwing.com/media/article/image/2022/09/26/69408_45a374833d-AE1E3C574D1112806E506CB75F2CFD32.jpg" alt="AE1E3C574D1112806E506CB75F2CFD32.jpg"><br><img src="https://cdn.acwing.com/media/article/image/2022/09/26/69408_48151ea53d-CEB6AB3CCF131B508A13A7476516560A.jpg" alt="CEB6AB3CCF131B508A13A7476516560A.jpg"><br><img src="https://cdn.acwing.com/media/article/image/2022/09/26/69408_4a5c32503d-DEE52D8A3307E687034E472D64674D40.jpg" alt="DEE52D8A3307E687034E472D64674D40.jpg"> </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;虽然但是 瘦西湖真的很好看哎&lt;/p&gt;</summary>
    
    
    
    <category term="分享日常" scheme="http://example.com/categories/%E5%88%86%E4%BA%AB%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="旅游" scheme="http://example.com/tags/%E6%97%85%E6%B8%B8/"/>
    
    <category term="扬州" scheme="http://example.com/tags/%E6%89%AC%E5%B7%9E/"/>
    
    <category term="ICPC" scheme="http://example.com/tags/ICPC/"/>
    
  </entry>
  
  <entry>
    <title>2021年五一北京之旅</title>
    <link href="http://example.com/2022/09/26/2021%E5%B9%B4%E4%BA%94%E4%B8%80%E5%8C%97%E4%BA%AC%E4%B9%8B%E6%97%85/"/>
    <id>http://example.com/2022/09/26/2021%E5%B9%B4%E4%BA%94%E4%B8%80%E5%8C%97%E4%BA%AC%E4%B9%8B%E6%97%85/</id>
    <published>2022-09-26T11:07:47.787Z</published>
    <updated>2022-09-26T11:20:42.548Z</updated>
    
    <content type="html"><![CDATA[<p>北京真好玩</p><span id="more"></span><p><img src="https://cdn.acwing.com/media/article/image/2022/09/26/69408_2d27901c3d-6EABBCA4A08A8C487CBA8FD5CD178296.jpg" alt="6EABBCA4A08A8C487CBA8FD5CD178296.jpg"><br><img src="https://cdn.acwing.com/media/article/image/2022/09/26/69408_340866fd3d-6F0D6434AD9A5FE702FBDB4F6D3DC499.jpg" alt="6F0D6434AD9A5FE702FBDB4F6D3DC499.jpg"><br><img src="https://cdn.acwing.com/media/article/image/2022/09/26/69408_365d86493d-47A1ADE319ADE69466C5D6545B93AFBA.jpg" alt="47A1ADE319ADE69466C5D6545B93AFBA.jpg"><br><img src="https://cdn.acwing.com/media/article/image/2022/09/26/69408_38c52a153d-93FE41C199D12AB1D19FE9A8023AAC4C.jpg" alt="93FE41C199D12AB1D19FE9A8023AAC4C.jpg"><br><img src="https://cdn.acwing.com/media/article/image/2022/09/26/69408_3c5237a13d-133C912EF8C029448DD059B5910E7B91.jpg" alt="133C912EF8C029448DD059B5910E7B91.jpg"><br><img src="https://cdn.acwing.com/media/article/image/2022/09/26/69408_3ec27b2b3d-1623979142192909D6D369AAE04898C9.jpg" alt="1623979142192909D6D369AAE04898C9.jpg"><br><img src="https://cdn.acwing.com/media/article/image/2022/09/26/69408_4167e5163d-B96F501975C3AF77B351DA116FBCBCC2.jpg" alt="B96F501975C3AF77B351DA116FBCBCC2.jpg"><br><img src="https://cdn.acwing.com/media/article/image/2022/09/26/69408_44abc72e3d-D9403FACB9665EA18EC83A86D00854B9.jpg" alt="D9403FACB9665EA18EC83A86D00854B9.jpg"><br><img src="https://cdn.acwing.com/media/article/image/2022/09/26/69408_51f467063d-E818A38D18B93240C78A6732CEEE13F9.jpg" alt="E818A38D18B93240C78A6732CEEE13F9.jpg"><br><img src="https://cdn.acwing.com/media/article/image/2022/09/26/69408_5a5000363d-DAF5CF5B912E01B40FBFF96D01146306.jpg" alt="DAF5CF5B912E01B40FBFF96D01146306.jpg"> </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;北京真好玩&lt;/p&gt;</summary>
    
    
    
    <category term="分享日常" scheme="http://example.com/categories/%E5%88%86%E4%BA%AB%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="北京" scheme="http://example.com/tags/%E5%8C%97%E4%BA%AC/"/>
    
    <category term="旅游" scheme="http://example.com/tags/%E6%97%85%E6%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>Splay模板</title>
    <link href="http://example.com/2022/09/26/splay%E6%A8%A1%E6%9D%BF/"/>
    <id>http://example.com/2022/09/26/splay%E6%A8%A1%E6%9D%BF/</id>
    <published>2022-09-26T10:51:34.571Z</published>
    <updated>2022-09-26T10:57:47.530Z</updated>
    
    <content type="html"><![CDATA[<p>splay大法  splay就是我爹</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">int idx = 0, root = 0;</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">    int s[2];</span><br><span class="line">    int v;</span><br><span class="line">    int cnt;</span><br><span class="line">    int size;</span><br><span class="line">    int p;</span><br><span class="line"></span><br><span class="line">    void init(int v1, int p1) &#123;</span><br><span class="line">        v = v1;</span><br><span class="line">        cnt = 1;</span><br><span class="line">        p = p1;</span><br><span class="line">        size = 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; tr[100010];</span><br><span class="line"></span><br><span class="line">void push_up(int k) &#123;</span><br><span class="line">    tr[k].size = tr[tr[k].s[0]].size + tr[tr[k].s[1]].size + tr[k].cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void rotate(int x) &#123;</span><br><span class="line">    int y = tr[x].p, z = tr[y].p;</span><br><span class="line">    int k = tr[y].s[1] == x;</span><br><span class="line">    tr[y].s[k] = tr[x].s[k ^ 1];</span><br><span class="line">    tr[tr[x].s[k ^ 1]].p = y;</span><br><span class="line">    tr[x].s[k ^ 1] = y;</span><br><span class="line">    tr[y].p = x;</span><br><span class="line">    tr[z].s[tr[z].s[1] == y] = x;</span><br><span class="line">    tr[x].p = z;</span><br><span class="line">    push_up(y), push_up(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void splay(int x, int k) &#123;</span><br><span class="line">    while (tr[x].p != k) &#123;</span><br><span class="line">        int y = tr[x].p, z = tr[y].p;</span><br><span class="line">        if (z != k)</span><br><span class="line">            (tr[y].s[0] == x) ^ (tr[x].s[0] == y) ? rotate(x) : rotate(y);</span><br><span class="line">        rotate(x);</span><br><span class="line">    &#125;</span><br><span class="line">    if (k == 0)root = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void insert(int v) &#123;</span><br><span class="line">    int x = root, p = 0;</span><br><span class="line">    while (x &amp;&amp; tr[x].v != v)</span><br><span class="line">        p = x, x = tr[x].s[v &gt; tr[x].v];</span><br><span class="line">    if (x)tr[x].cnt++;</span><br><span class="line">    else &#123;</span><br><span class="line">        x = ++idx;</span><br><span class="line">        tr[p].s[v &gt; tr[p].v] = x;</span><br><span class="line">        tr[x].init(v, p);</span><br><span class="line">    &#125;</span><br><span class="line">    splay(x, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int get_val(int k)//查询排名k的节点</span><br><span class="line">&#123;</span><br><span class="line">    int x = root;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        int y = tr[x].s[0];</span><br><span class="line">        if (tr[y].size + tr[x].cnt &lt; k) &#123;</span><br><span class="line">            k -= tr[y].size + tr[x].cnt;</span><br><span class="line">            x = tr[x].s[1];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (tr[y].size &gt;= k)x = y;</span><br><span class="line">            else break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    splay(x, 0);</span><br><span class="line">    return tr[x].v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void find(int v) &#123;//查找v所在的节点 并把节点转到根</span><br><span class="line">    int x = root;</span><br><span class="line">    while (tr[x].s[v &gt; tr[x].v] &amp;&amp; v != tr[x].v) x = tr[x].s[v &gt; tr[x].v];</span><br><span class="line">    splay(x, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int get_rank(int v) &#123;</span><br><span class="line">    find(v);</span><br><span class="line">    return tr[tr[root].s[0]].size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int get_pre(int v) &#123;//获取v的前驱</span><br><span class="line">    find(v);</span><br><span class="line">    int x = root;</span><br><span class="line">    if (tr[x].v &lt; v)return x;</span><br><span class="line">    x = tr[x].s[0];</span><br><span class="line">    while (tr[x].s[1])x = tr[x].s[1];</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int get_suc(int v) &#123;//获取x的后继</span><br><span class="line">    find(v);</span><br><span class="line">    int x = root;</span><br><span class="line">    if (tr[x].v &gt; v) return x;</span><br><span class="line">    x = tr[x].s[1];</span><br><span class="line">    while (tr[x].s[0])x = tr[x].s[0];</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void del(int v) &#123;//删除数字v若有多个相同只删除一个</span><br><span class="line">    int pre = get_pre(v);</span><br><span class="line">    int suc = get_suc(v);</span><br><span class="line">    splay(pre, 0), splay(suc, pre);</span><br><span class="line">    int del = tr[suc].s[0];</span><br><span class="line">    if (tr[del].cnt &gt; 1)</span><br><span class="line">        tr[del].cnt--, splay(del, 0);</span><br><span class="line">    else tr[suc].s[0] = 0, splay(suc, 0);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void output(int k) &#123;//中序遍历输出</span><br><span class="line">    if (tr[k].s[0])</span><br><span class="line">        output(tr[k].s[0]);</span><br><span class="line">    if (tr[k].v &lt;= n &amp;&amp; tr[k].v &gt;= 1)</span><br><span class="line">        std::cout &lt;&lt; tr[k].v &lt;&lt; &quot; &quot;;</span><br><span class="line">    if (tr[k].s[1])</span><br><span class="line">        output(tr[k].s[1]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed main() &#123;</span><br><span class="line">    std::ios::sync_with_stdio(false);</span><br><span class="line">    std::cin.tie(0);</span><br><span class="line">    int n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    insert(100000000), insert(-100000000);</span><br><span class="line">    while (n--) &#123;</span><br><span class="line">        int op, x;</span><br><span class="line">        std::cin &gt;&gt; op &gt;&gt; x;</span><br><span class="line">        switch (op) &#123;</span><br><span class="line">            case 1:</span><br><span class="line">                insert(x);</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                del(x);</span><br><span class="line">                break;</span><br><span class="line">            case 3:</span><br><span class="line">                std::cout &lt;&lt; get_rank(x) &lt;&lt; &quot;\n&quot;;</span><br><span class="line">                break;</span><br><span class="line">            case 4:</span><br><span class="line">                std::cout &lt;&lt; get_val(x + 1) &lt;&lt; &quot;\n&quot;;</span><br><span class="line">                break;</span><br><span class="line">            case 5:</span><br><span class="line">                std::cout &lt;&lt; tr[get_pre(x)].v &lt;&lt; &quot;\n&quot;;</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                std::cout &lt;&lt; tr[get_suc(x)].v &lt;&lt; &quot;\n&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>所以呢就别不快乐。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;splay大法  splay就是我爹&lt;/p&gt;</summary>
    
    
    
    <category term="模板" scheme="http://example.com/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%A8%A1%E6%9D%BF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="Splay" scheme="http://example.com/categories/%E6%A8%A1%E6%9D%BF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Splay/"/>
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="模板" scheme="http://example.com/tags/%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="平衡树" scheme="http://example.com/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
    <category term="Splay" scheme="http://example.com/tags/Splay/"/>
    
  </entry>
  
  <entry>
    <title>树链剖分换根操作</title>
    <link href="http://example.com/2022/09/26/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%E6%8D%A2%E6%A0%B9%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2022/09/26/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%E6%8D%A2%E6%A0%B9%E6%93%8D%E4%BD%9C/</id>
    <published>2022-09-26T10:49:46.290Z</published>
    <updated>2022-09-26T10:57:53.774Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://www.acwing.com/problem/content/description/2526/">2524. 树链剖分II - AcWing题库</a></p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">6</span><br><span class="line">1 2 3 4 5 6</span><br><span class="line">1 2 1 4 4</span><br><span class="line">6</span><br><span class="line">4 5 6</span><br><span class="line">2 2 4 1</span><br><span class="line">5 1</span><br><span class="line">1 4</span><br><span class="line">3 1 2</span><br><span class="line">4 2 5</span><br><span class="line">输出：</span><br><span class="line">15</span><br><span class="line">24</span><br><span class="line">19</span><br></pre></td></tr></table></figure><span id="more"></span><p>首先换根的操作 并不会影响路径权值的<strong>修改或查询</strong>操作， 只会影响子树权值的<strong>修改或查询</strong>操作。</p><p>因为无论以谁为根，树上两点之前的路径肯定不是会变化的，这个直接套用  根为1  的查询修改即可。</p><p>其次，对子树操作时要进行分类讨论：</p><p>令root为新根，u为要操作的子树节点   v &#x3D; lca( root , u)。</p><p>1 .  当v !&#x3D; u时  如图所示，新根并不影响子树u 所以 直接   查询或修改  子树u即可。</p><p><img src="https://cdn.acwing.com/media/article/image/2022/08/10/69408_9e8900a918-135F3DC507014A67538F3914964D70E9.png" alt="135F3DC507014A67538F3914964D70E9.png"> </p><p>2 .  当v&#x3D;&#x3D;u时  如图所示， 我们找到路径(v,u)中的u节点的儿子<strong>ff</strong> ,查询子树u的权值和(根为新根)，等价于 查询整棵树的权值和减去ff子树的权值和(根为1)。 查询子树u的权值为 +k (根为新根)，等价于 修改整棵树的权值  +k   ff子树的权值   -k  (根为1)。 </p><p><img src="https://cdn.acwing.com/media/article/image/2022/08/10/69408_4b42674018-572CB3A4398FC2FBE7AB94354840DB5D.png" alt="572CB3A4398FC2FBE7AB94354840DB5D.png"> </p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line">#pragma GCC optimize(2)</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using LL = long long;</span><br><span class="line">const int N = 1e5 + 10;</span><br><span class="line"></span><br><span class="line">std::vector&lt;std::vector&lt;int&gt;&gt; g(N);</span><br><span class="line"></span><br><span class="line">int in[N];</span><br><span class="line">int n, m, cnt, root = 1;</span><br><span class="line">int id[N], son[N], sz[N], depth[N], fa[N];</span><br><span class="line">int nw[N], top[N];//新点的权值 以及每个重点的头</span><br><span class="line"></span><br><span class="line">/*树链*/</span><br><span class="line">void dfs(int v, int father) &#123;</span><br><span class="line">    depth[v] = depth[father] + 1;</span><br><span class="line">    fa[v] = father;</span><br><span class="line">    sz[v] = 1;</span><br><span class="line">    for (int i: g[v]) &#123;</span><br><span class="line">        if (i == father) continue;</span><br><span class="line">        dfs(i, v);</span><br><span class="line">        sz[v] += sz[i];</span><br><span class="line">        if (sz[i] &gt; sz[son[v]])son[v] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs2(int v, int t) &#123;</span><br><span class="line">    id[v] = ++cnt;</span><br><span class="line">    nw[cnt] = in[v];</span><br><span class="line">    top[v] = t;</span><br><span class="line">    if (!son[v])return;</span><br><span class="line">    dfs2(son[v], t);</span><br><span class="line">    for (int i: g[v]) &#123;</span><br><span class="line">        if (i == fa[v] || i == son[v])continue;</span><br><span class="line">        dfs2(i, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*线段树*/</span><br><span class="line">namespace Segment_tree &#123;</span><br><span class="line">    struct tree &#123;</span><br><span class="line">        int l, r;</span><br><span class="line">        LL sum, lazy;</span><br><span class="line">    &#125; tr[N * 4];</span><br><span class="line"></span><br><span class="line">    void push_up(tree &amp;u, tree &amp;l, tree &amp;r) &#123;</span><br><span class="line">        u.sum = l.sum + r.sum;</span><br><span class="line">        u.l = l.l, u.r = r.r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void push_up(int u) &#123;</span><br><span class="line">        push_up(tr[u], tr[u &lt;&lt; 1], tr[u &lt;&lt; 1 | 1]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void build(int v, int l, int r) &#123;</span><br><span class="line">        if (l == r) &#123;</span><br><span class="line">            tr[v] = &#123;l, l, nw[l], 0&#125;;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int mid = l + r &gt;&gt; 1;</span><br><span class="line">        build(v &lt;&lt; 1, l, mid);</span><br><span class="line">        build(v &lt;&lt; 1 | 1, mid + 1, r);</span><br><span class="line">        push_up(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void push_down(int u) &#123;</span><br><span class="line">        if (tr[u].lazy) &#123;</span><br><span class="line">            auto &amp;left = tr[u &lt;&lt; 1], &amp;right = tr[u &lt;&lt; 1 | 1];</span><br><span class="line">            left.sum += tr[u].lazy * (left.r - left.l + 1);</span><br><span class="line">            right.sum += tr[u].lazy * (right.r - right.l + 1);</span><br><span class="line">            left.lazy += tr[u].lazy;</span><br><span class="line">            right.lazy += tr[u].lazy;</span><br><span class="line">            tr[u].lazy = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void update(int u, int l, int r, int k) &#123;</span><br><span class="line">        if (l &lt;= tr[u].l &amp;&amp; r &gt;= tr[u].r) &#123;</span><br><span class="line">            tr[u].lazy += k;</span><br><span class="line">            tr[u].sum += (tr[u].r - tr[u].l + 1) * k;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        push_down(u);</span><br><span class="line">        int mid = tr[u].l + tr[u].r &gt;&gt; 1;</span><br><span class="line">        if (l &lt;= mid)update(u &lt;&lt; 1, l, r, k);</span><br><span class="line">        if (r &gt; mid)update(u &lt;&lt; 1 | 1, l, r, k);</span><br><span class="line">        push_up(u);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LL query(int u, int l, int r) &#123;</span><br><span class="line">        if (l &lt;= tr[u].l &amp;&amp; r &gt;= tr[u].r)</span><br><span class="line">            return tr[u].sum;</span><br><span class="line">        push_down(u);</span><br><span class="line">        int mid = tr[u].l + tr[u].r &gt;&gt; 1;</span><br><span class="line">        LL res = 0;</span><br><span class="line">        if (l &lt;= mid)res += query(u &lt;&lt; 1, l, r);</span><br><span class="line">        if (r &gt; mid)res += query(u &lt;&lt; 1 | 1, l, r);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">using namespace Segment_tree;</span><br><span class="line"></span><br><span class="line">int lca(int u, int v) &#123;</span><br><span class="line">    while (top[u] != top[v]) &#123;</span><br><span class="line">        if (depth[top[u]] &lt;= depth[top[v]])std::swap(v, u);</span><br><span class="line">        u = fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    return depth[u] &lt; depth[v] ? u : v;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int find(int u,int v)&#123;//找到u到v路径上v的儿子</span><br><span class="line">    while(top[u]!=top[v])&#123;//不在一个重链上</span><br><span class="line">        if(fa[top[u]]==v)return top[u];//如果u的重链顶点的父节点是v那直接返回重链顶点</span><br><span class="line">        u=fa[top[u]];//u到上一个重链上</span><br><span class="line">    &#125;//因为v是u的公共祖先 所以 v一定在u的上面 不需要换位</span><br><span class="line">    //此时uv已在一根重链上 直接返回v的重儿子即可</span><br><span class="line">    return son[v];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void update_path(int u, int v, int k) &#123;</span><br><span class="line">    while (top[u] != top[v]) &#123;</span><br><span class="line">        if (depth[top[u]] &lt; depth[top[v]])</span><br><span class="line">            std::swap(u, v);</span><br><span class="line">        update(1, id[top[u]], id[u], k);</span><br><span class="line">        u = fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    if (depth[u] &lt; depth[v])std::swap(u, v);</span><br><span class="line">    update(1, id[v], id[u], k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void update_tree(int u, int k) &#123;</span><br><span class="line">    if(lca(root,u)!=u) update(1, id[u], id[u] + sz[u] - 1, k);</span><br><span class="line">    else &#123;</span><br><span class="line">        int ff=find(root,u);</span><br><span class="line">        update(1,1,n,k);</span><br><span class="line">        if(u!=root)</span><br><span class="line">            update(1,id[ff],id[ff]+sz[ff]-1,-k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL query_tree(int u) &#123;</span><br><span class="line">    if(lca(root,u)!=u) return query(1, id[u], id[u] + sz[u] - 1);</span><br><span class="line">    else &#123;</span><br><span class="line">        if(root==u)return query(1,1,n);</span><br><span class="line">        int ff=find(root,u);</span><br><span class="line">       return query(1,1,n)-query(1,id[ff],id[ff]+sz[ff]-1);</span><br><span class="line">      // return ff;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL query_path(int u, int v) &#123;</span><br><span class="line">    LL res = 0;</span><br><span class="line">    while (top[u] != top[v]) &#123;</span><br><span class="line">        if (depth[top[u]] &lt; depth[top[v]])std::swap(u, v);</span><br><span class="line">        res += query(1, id[top[u]], id[u]);</span><br><span class="line">        u = fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    if (depth[u] &lt; depth[v])std::swap(u, v);</span><br><span class="line">    res += query(1, id[v], id[u]);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed main() &#123;</span><br><span class="line"></span><br><span class="line">    std::ios::sync_with_stdio(false);</span><br><span class="line">    std::cin.tie(0);</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">        std::cin &gt;&gt; in[i];</span><br><span class="line">    for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        int a;</span><br><span class="line">        std::cin&gt;&gt;a;</span><br><span class="line">        g[a].push_back(i+1);</span><br><span class="line">        g[i+1].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cin &gt;&gt; m;</span><br><span class="line">    dfs(1, 0);</span><br><span class="line">    dfs2(1, 1);</span><br><span class="line">    build(1, 1, cnt);</span><br><span class="line">    while (m--) &#123;</span><br><span class="line">        int q, u, v, k;</span><br><span class="line">        std::cin &gt;&gt; q;</span><br><span class="line">        if (q == 1) &#123;</span><br><span class="line">            std::cin &gt;&gt; root;</span><br><span class="line">        &#125; else if (q == 2) &#123;</span><br><span class="line">            std::cin &gt;&gt; u &gt;&gt; v &gt;&gt; k;</span><br><span class="line">          update_path(u, v, k);</span><br><span class="line">        &#125; else if (q == 3) &#123;</span><br><span class="line">            std::cin &gt;&gt; u &gt;&gt; k;</span><br><span class="line">            update_tree(u, k);</span><br><span class="line">        &#125; else if (q == 4) &#123;</span><br><span class="line">            std::cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">            std::cout &lt;&lt; query_path(u, v) &lt;&lt; &quot;\n&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            std::cin &gt;&gt; u;</span><br><span class="line">            std::cout &lt;&lt; query_tree(u) &lt;&lt; &quot;\n&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4><blockquote><p>所以呢就别不快乐。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.acwing.com/problem/content/description/2526/&quot;&gt;2524. 树链剖分II - AcWing题库&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;样例&quot;&gt;&lt;a href=&quot;#样例&quot; class=&quot;headerlink&quot; title=&quot;样例&quot;&gt;&lt;/a&gt;样例&lt;/h4&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 2 3 4 5 6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 2 1 4 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4 5 6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2 2 4 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3 1 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4 2 5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="模板" scheme="http://example.com/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%A8%A1%E6%9D%BF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树链剖分" scheme="http://example.com/categories/%E6%A8%A1%E6%9D%BF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="模板" scheme="http://example.com/tags/%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="树链剖分" scheme="http://example.com/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>lct模板</title>
    <link href="http://example.com/2022/09/26/lct%E6%A8%A1%E6%9D%BF/"/>
    <id>http://example.com/2022/09/26/lct%E6%A8%A1%E6%9D%BF/</id>
    <published>2022-09-26T10:47:39.926Z</published>
    <updated>2022-09-26T10:57:46.455Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">#pragma GCC optimize(3)</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">#define fa(x) tr[x].p</span><br><span class="line">#define lc(x) tr[x].s[0]</span><br><span class="line">#define rc(x) tr[x].s[1]</span><br><span class="line">#define notroot(x) lc(fa(x))==x||rc(fa(x))==x</span><br><span class="line"></span><br><span class="line">const int N = 1e5+10;</span><br><span class="line">int n,m;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int s[2],p,v;</span><br><span class="line">    int sum,tag;</span><br><span class="line">&#125;tr[N];</span><br><span class="line">/*不会改变虚实边*/</span><br><span class="line">inline void pushup(int x)&#123;</span><br><span class="line">    tr[x].sum=tr[lc(x)].sum^tr[rc(x)].sum^tr[x].v;</span><br><span class="line">&#125;</span><br><span class="line">inline void pushdown(int x)&#123;</span><br><span class="line">    if(tr[x].tag)&#123;</span><br><span class="line">        std::swap(lc(x),rc(x));</span><br><span class="line">        tr[lc(x)].tag^=1;</span><br><span class="line">        tr[rc(x)].tag^=1;</span><br><span class="line">        tr[x].tag=0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline void rotate(int x)&#123;</span><br><span class="line">    int y=fa(x),z=fa(y);</span><br><span class="line">    int k=rc(y)==x;</span><br><span class="line">    if(notroot(y)) tr[z].s[rc(z)==y]=x;</span><br><span class="line">    fa(x)=z;</span><br><span class="line">    tr[y].s[k]=tr[x].s[k^1];</span><br><span class="line">    fa(tr[x].s[k^1])=y;</span><br><span class="line">    tr[x].s[k^1]=y;</span><br><span class="line">    fa(y)=x;</span><br><span class="line">    pushup(y),pushup(x);</span><br><span class="line">&#125;</span><br><span class="line">inline void pushall(int x)&#123;//递归 先到树根 然后一层一层 pushdown</span><br><span class="line">    if(notroot(x))pushall(fa(x));</span><br><span class="line">    pushdown(x);</span><br><span class="line">&#125;</span><br><span class="line">inline void splay(int x)&#123;</span><br><span class="line">    pushall(x);</span><br><span class="line">    while(notroot(x))&#123;</span><br><span class="line">        int y=fa(x),z=fa(y);</span><br><span class="line">        if(notroot(y))</span><br><span class="line">        (rc(y)==x)^(rc(z)==y)?rotate(x):rotate(y);</span><br><span class="line">        rotate(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*会改变虚实边*/</span><br><span class="line">inline void access(int x)&#123;//x到根节点权变成实边//</span><br><span class="line">    for(int y=0;x;)&#123;</span><br><span class="line">        splay(x);</span><br><span class="line">        rc(x)=y;</span><br><span class="line">        pushup(x);</span><br><span class="line">        y=x,x=fa(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">inline void makeroot(int x)&#123;//原树中 x为原点</span><br><span class="line">    access(x);//打通路径</span><br><span class="line">    splay(x);//翻上来</span><br><span class="line">    tr[x].tag^=1;//旋转</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline void split(int x,int y)&#123;//将x y路径分离出来</span><br><span class="line">    makeroot(x);//将x变成树根</span><br><span class="line">    access(y);//给x于y通路  此时为啥不是直接是tr[x].sum 因为 通路之后 x不一定是平衡树的根节点</span><br><span class="line">    splay(y);//这里splay（x）splay（y）都可以  splay哪个就输出哪个</span><br><span class="line">&#125;</span><br><span class="line">inline int findroot(int x)&#123;//找树根</span><br><span class="line">    access(x);</span><br><span class="line">    splay(x);</span><br><span class="line">    while(lc(x))</span><br><span class="line">    pushdown(x),x=lc(x);</span><br><span class="line">    splay(x);</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line">inline void link(int x,int y)&#123;//连接</span><br><span class="line">    makeroot(x);//先看看是不是在一颗树内 先把x变成树根</span><br><span class="line">    if(findroot(y)!=x)fa(x)=y;//找出y的根是不是x 不是就把树x加到y里</span><br><span class="line">&#125;</span><br><span class="line">inline void cut(int x,int y)&#123;</span><br><span class="line">    makeroot(x);</span><br><span class="line">    if(findroot(y)==x&amp;&amp;fa(y)==x&amp;&amp;!lc(y))&#123;   //首先判断x y是否在一个平衡树里 然后 x是y的节点  然后x是y的前一个（因为平衡树有边 并不代表原树有边）</span><br><span class="line">        rc(x)=fa(y)=0;</span><br><span class="line">        pushup(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    std::ios::sync_with_stdio(false);</span><br><span class="line">    std::cin.tie(0);</span><br><span class="line">    std::cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) std::cin&gt;&gt;tr[i].v;</span><br><span class="line">    while (m -- )&#123;</span><br><span class="line">        int t,x,y;</span><br><span class="line">        std::cin&gt;&gt;t&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        if(t==0)&#123;</span><br><span class="line">            split(x,y);</span><br><span class="line">            std::cout&lt;&lt;tr[y].sum&lt;&lt;&quot;\n&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(t==1) link(x,y);</span><br><span class="line">        else if(t==2) cut(x,y);</span><br><span class="line">        else &#123;</span><br><span class="line">            splay(x);</span><br><span class="line">            tr[x].v=y;</span><br><span class="line">            pushup(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="模板" scheme="http://example.com/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%A8%A1%E6%9D%BF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="Link Cut Tree" scheme="http://example.com/categories/%E6%A8%A1%E6%9D%BF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Link-Cut-Tree/"/>
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="动态树" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E6%A0%91/"/>
    
    <category term="Link Cut Tree" scheme="http://example.com/tags/Link-Cut-Tree/"/>
    
    <category term="模板" scheme="http://example.com/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>自定义结构体，优先队列如何重载运算符</title>
    <link href="http://example.com/2022/09/26/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%20%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9C%E5%BE%97%E5%88%B0%E6%83%B3%E8%A6%81%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    <id>http://example.com/2022/09/26/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%20%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9C%E5%BE%97%E5%88%B0%E6%83%B3%E8%A6%81%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/</id>
    <published>2022-09-26T10:12:54.233Z</published>
    <updated>2022-09-26T10:58:02.862Z</updated>
    
    <content type="html"><![CDATA[<p>语言：c++</p><p>头文件：queue</p><h4 id="首先是-std-less和std-greater两个模板的使用"><a href="#首先是-std-less和std-greater两个模板的使用" class="headerlink" title="首先是 std::less和std::greater两个模板的使用"></a>首先是 std::less和std::greater两个模板的使用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   template&lt;typename _Iterator, typename _Value&gt;</span><br><span class="line">bool</span><br><span class="line">operator()(_Iterator __it, _Value&amp; __val)</span><br><span class="line">&#123; return bool(_M_comp(*__it, __val)); &#125;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><span id="more"></span><p><strong>less需要重载结构体的小于   以下内容语言描述很抽象 直接看演示</strong></p><p>（友元函数省略 因为跟结构体内重载一个意思）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct data1&#123;</span><br><span class="line">    int num;</span><br><span class="line">    int time;</span><br><span class="line">    std::string name;</span><br><span class="line">    bool operator &lt;(const data1&amp;a)const&#123;//这里最后const不加会报错的//这里引用 是因为引用更快一点</span><br><span class="line">        return num&gt;a.num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">signed main()</span><br><span class="line">&#123;</span><br><span class="line">    std::priority_queue&lt;data1,std::vector&lt;data1&gt;,std::less&lt;data1&gt;&gt;q;</span><br><span class="line">    std::string str=&quot;aa&quot;;</span><br><span class="line">    for(int i=1; i&lt;=10; i++)</span><br><span class="line">        q.push(&#123;i,i+10,str&#125;);</span><br><span class="line">    while(q.size())&#123;</span><br><span class="line">        auto cc=q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        std::cout&lt;&lt;cc.num&lt;&lt;&quot;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的为：1，2，3，4，5，6，7，8，9，10；</p><p>如果&lt;是下面方式重载的话 得到的结果为：10，9，8，7，6，5，4，3，2，1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool operator &lt;(const data1&amp;a)const</span><br><span class="line">  &#123;</span><br><span class="line">      return num&lt;a.num;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>你想定义的顺序跟优先队列出来的恰恰相反</p><p><strong>然后 是greater 模板代码如下  可以看出greater需要重载的是&gt;</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename _Tp&gt;</span><br><span class="line">  struct greater : public binary_function&lt;_Tp, _Tp, bool&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    _GLIBCXX14_CONSTEXPR</span><br><span class="line">    bool</span><br><span class="line">    operator()(const _Tp&amp; __x, const _Tp&amp; __y) const</span><br><span class="line">    &#123; return __x &gt; __y; &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>greater恰好于less相反</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::priority_queue&lt;data1,std::vector&lt;data1&gt;,std::greater&lt;data1&gt;&gt;q;</span><br><span class="line"></span><br><span class="line"> bool operator &gt;(const data1&amp;a)const&#123;</span><br><span class="line">     return num&lt;a.num;</span><br><span class="line"> &#125;// 得到的结果为：10，9，8，7，6，5，4，3，2，1</span><br><span class="line"> bool operator &gt;(const data1&amp;a)const&#123;</span><br><span class="line"> return num&gt;a.num;</span><br><span class="line"> &#125;得到的为：1，2，3，4，5，6，7，8，9，10；</span><br></pre></td></tr></table></figure><p>greater也是想定义的顺序跟优先队列出来的恰恰相反</p><p>由上推出：</p><p><strong>当为非结构体时（不需要重载的基本类型） less是大根堆，greater是小根堆，而优先队列默认的是大根堆。</strong> </p><h4 id="自定义比较结构体"><a href="#自定义比较结构体" class="headerlink" title="自定义比较结构体"></a>自定义比较结构体</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct cmp&#123;</span><br><span class="line">    bool operator ()(const data1 &amp;a, const data1 &amp;b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a.num&lt;b.num;// 按照num从小到大排列</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct cmp&#123;</span><br><span class="line">    bool operator ()(const data1 &amp;a, const data1 &amp;b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a.num&gt;b.num;// 按照num从大到小排列</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">std::priority_queue&lt;data1,std::vector&lt;data1&gt;,cmp&gt;q;//</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>敬请斧正。</p><blockquote><p>所以呢就别不快乐。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;语言：c++&lt;/p&gt;
&lt;p&gt;头文件：queue&lt;/p&gt;
&lt;h4 id=&quot;首先是-std-less和std-greater两个模板的使用&quot;&gt;&lt;a href=&quot;#首先是-std-less和std-greater两个模板的使用&quot; class=&quot;headerlink&quot; title=&quot;首先是 std::less和std::greater两个模板的使用&quot;&gt;&lt;/a&gt;首先是 std::less和std::greater两个模板的使用&lt;/h4&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;   template&amp;lt;typename _Iterator, typename _Value&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bool&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;operator()(_Iterator __it, _Value&amp;amp; __val)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123; return bool(_M_comp(*__it, __val)); &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="竞赛分享" scheme="http://example.com/categories/%E7%AB%9E%E8%B5%9B%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="stl" scheme="http://example.com/tags/stl/"/>
    
    <category term="优先队列" scheme="http://example.com/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>分享一个有意思的</title>
    <link href="http://example.com/2022/06/02/%E5%88%86-%E4%B8%80%E4%B8%AA%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84/"/>
    <id>http://example.com/2022/06/02/%E5%88%86-%E4%B8%80%E4%B8%AA%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84/</id>
    <published>2022-06-01T17:09:18.000Z</published>
    <updated>2022-06-01T18:08:56.281Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.ipip5.com/ipimg/" alt="3"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://www.ipip5.com/ipimg/&quot; alt=&quot;3&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="分享日常" scheme="http://example.com/categories/%E5%88%86%E4%BA%AB%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="小插件" scheme="http://example.com/tags/%E5%B0%8F%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Filling pools</title>
    <link href="http://example.com/2022/06/02/Filling-pools/"/>
    <id>http://example.com/2022/06/02/Filling-pools/</id>
    <published>2022-06-01T16:56:44.000Z</published>
    <updated>2022-06-01T18:06:47.726Z</updated>
    
    <content type="html"><![CDATA[<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>Counting regions<a href="https://ac.nowcoder.com/acm/contest/33549/G">https://ac.nowcoder.com/acm/contest/33549/G</a></p><p>问n个点（n为奇数）每两个点之间都连一条直线,数多边形内的区域数。对1000000007取模</p><span id="more"></span><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p><img src="https://cdn.acwing.com/media/article/image/2022/04/30/69408_a818b539c8-G.png" alt="G.png"><br>欧拉示性数公式：一个没有边的相交的图中V-E+F&#x3D;2</p><p>点数-边的数量(包含弧)+分割区域+外围区域&#x3D;2</p><p>本题中n个顶点 边相交了C(n,4)次 我们把每一条边都当成被分成若干份。</p><p>那这些小边的数量的就可以套用欧拉公式</p><p>如果 黄色是顶点 黑色是边</p><p>F&#x3D;E-V+2</p><p>先求v（点的数量）:本身有n个顶点每两条直线相交得到一个点，一条直线有2个点 所以每四个顶点就会产生一个交点</p><p>V&#x3D;C(n,4)+n;</p><p>然后求E(边的数量)：  每两个顶点会得到一条直线，每两条直线相交分把这两条线分成四份，交点。</p><p>E&#x3D;C(n,2)+C(n,4)*2;</p><p>F&#x3D;C(n,2)+C(n,4)*2-C(n,4)-n+2;</p><p>F&#x3D;C(n,2)+C(n,4)-n+2;</p><p>由于欧拉公式里的F是算上外围区域的所以要减去1</p><p>F&#x3D;C(n,2)+C(n,4)-n+1;<img src="/G.png"></p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入：3 输出1</span><br></pre></td></tr></table></figure><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#define int long long</span><br><span class="line">#define mod  1000000007</span><br><span class="line"></span><br><span class="line">int  qmi(int a,int b)&#123;</span><br><span class="line">    int ans=1;</span><br><span class="line">    a%=mod;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)ans=ans*a%mod;</span><br><span class="line">        b&gt;&gt;=1;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;   </span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">   std:: cin&gt;&gt;n;</span><br><span class="line">    int  cn2 =n*(n-1)%mod*qmi(2,mod-2);</span><br><span class="line">    int cn4 = n*(n-1)%mod*(n-2)%mod*(n-3)%mod*qmi(24,mod-2);</span><br><span class="line">    //cout&lt;&lt;cn2&lt;&lt;&quot;   &quot;&lt;&lt;cn4&lt;&lt;endl;</span><br><span class="line">   int  ans = cn2 + cn4 - n + 1;</span><br><span class="line">   std:: cout&lt;&lt;ans%mod&lt;&lt;&quot;\n&quot;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;Counting regions&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/33549/G&quot;&gt;https://ac.nowcoder.com/acm/contest/33549/G&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;问n个点（n为奇数）每两个点之间都连一条直线,数多边形内的区域数。对1000000007取模&lt;/p&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="图论" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="欧拉示性数公式" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%9B%BE%E8%AE%BA/%E6%AC%A7%E6%8B%89%E7%A4%BA%E6%80%A7%E6%95%B0%E5%85%AC%E5%BC%8F/"/>
    
    
    <category term="题解" scheme="http://example.com/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="牛客" scheme="http://example.com/tags/%E7%89%9B%E5%AE%A2/"/>
    
    <category term="图论" scheme="http://example.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>佳佳的斐波那契</title>
    <link href="http://example.com/2022/06/02/%E4%BD%B3%E4%BD%B3%E7%9A%84%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/"/>
    <id>http://example.com/2022/06/02/%E4%BD%B3%E4%BD%B3%E7%9A%84%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/</id>
    <published>2022-06-01T16:56:01.000Z</published>
    <updated>2022-06-01T18:06:51.709Z</updated>
    
    <content type="html"><![CDATA[<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p><a href="https://www.acwing.com/problem/content/description/1306/">1304. 佳佳的斐波那契 - AcWing题库</a></p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：5 5 输出1</span><br><span class="line">解释：T(5)=(1+2×1+3×2+4×3+5×5)mod5=1</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><img src="https://cdn.acwing.com/media/article/image/2022/04/30/69408_18c8597ec7-616D8CEFDD48B71B0703D84EB433F961.png" alt="616D8CEFDD48B71B0703D84EB433F961.png"> </p><p>所以我们求T（i）只要求出S(i)和C(i)即可<br>C(i)的递归方式很简单 C(i)&#x3D;C(i-1)+S(i);<br>然后再写个矩阵乘法就可以算出来了</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define N 4</span><br><span class="line">#define int long long</span><br><span class="line"></span><br><span class="line">int n,m;</span><br><span class="line"></span><br><span class="line">void mul(int a[][N],int b[][N],int c[][N])//矩阵乘法</span><br><span class="line">&#123;</span><br><span class="line">    int temp[N][N]=&#123;0&#125;;</span><br><span class="line">    for(int i=0; i&lt;N; i++)</span><br><span class="line">        for(int j=0; j&lt;N; j++)</span><br><span class="line">            for(int k=0; k&lt;N; k++)</span><br><span class="line">            &#123;</span><br><span class="line">            temp[i][j]+=b[i][k]*c[k][j]%m;</span><br><span class="line">            temp[i][j]%=m;</span><br><span class="line">            &#125;</span><br><span class="line">    memcpy(a,temp,sizeof temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">signed main()</span><br><span class="line">&#123;</span><br><span class="line">    std::ios::sync_with_stdio(false);</span><br><span class="line">    std::cin.tie(nullptr);</span><br><span class="line">    std::cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    int f[4][4]= &#123;1,1,1,0&#125;;//f[i-1],f[i],s[i],c[i-1];</span><br><span class="line">    int k[4][4]=</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;0,1,0,0&#125;,</span><br><span class="line">        &#123;1,1,1,0&#125;,</span><br><span class="line">        &#123;0,0,1,1&#125;,</span><br><span class="line">        &#123;0,0,0,1&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    n--;</span><br><span class="line">    int zz=n+1;</span><br><span class="line">    while(n)</span><br><span class="line">    &#123;</span><br><span class="line">        if(n&amp;1)</span><br><span class="line">            mul(f,f,k);//f=f*k;</span><br><span class="line">        n&gt;&gt;=1;</span><br><span class="line">        mul(k,k,k);//k=k*k;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;((f[0][2]*zz%m-f[0][3]%m)%m+m)%m&lt;&lt;&quot;\n&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>所以呢就别不快乐。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.acwing.com/problem/content/description/1306/&quot;&gt;1304. 佳佳的斐波那契 - AcWing题库&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;样例&quot;&gt;&lt;a href=&quot;#样例&quot; class=&quot;headerlink&quot; title=&quot;样例&quot;&gt;&lt;/a&gt;样例&lt;/h4&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：5 5 输出1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：T(5)=(1+2×1+3×2+4×3+5×5)mod5=1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="数学" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="矩阵乘法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E6%95%B0%E5%AD%A6/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/"/>
    
    
    <category term="题解" scheme="http://example.com/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="数学" scheme="http://example.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="提高课" scheme="http://example.com/tags/%E6%8F%90%E9%AB%98%E8%AF%BE/"/>
    
    <category term="矩阵快速幂" scheme="http://example.com/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
  </entry>
  
  <entry>
    <title>最大公约数</title>
    <link href="http://example.com/2022/06/02/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/"/>
    <id>http://example.com/2022/06/02/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/</id>
    <published>2022-06-01T16:55:38.000Z</published>
    <updated>2022-06-01T18:06:48.783Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://www.acwing.com/problem/content/222/">220. 最大公约数 - AcWing题库</a></p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入:4 输出:4</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="算法1"><a href="#算法1" class="headerlink" title="算法1"></a>算法1</h3><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>gcd(x,y)&#x3D;&#x3D;素数 P ,且1&lt;&#x3D;x,y&lt;&#x3D;N</p><p>显然gcd(x&#x2F;p,y&#x2F;p)&#x3D;&#x3D;1,然后这就联想到欧拉函数，1~n里有多少个数互质。</p><p>先说结论</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(int i=1;i&lt;=cnt;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       ans+=pre[n/primes[i]]&lt;&lt;1|1;//pre数组就是欧拉函数</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>我解释一下我看题解的时候遇到一些疑惑</p><p>1.为什么 ans为什么每次加上的是pre[n&#x2F;primes[i]]*2+1？</p><pre><code>  pre[i]是1~N中互质的对数，但是题目中的x,y是分顺序的，所以要乘以2，为什么加1，因为x,y为相同的一个质数的时候也是符合条件的x，y;</code></pre><p>2.ans每次加上pre[n&#x2F;primes[i]]*2+1不会有数对已经被统计过了还会再被统计吗？</p><p> for(int i&#x3D;1;i&lt;&#x3D;cnt;i++)循环是把所有的（x,y）进行了一个集合的划分，也就是gcd(x,y)&#x3D;primes[i1];</p><p>所以如果这对x,y在这一i的循环出现过（说明说明gcd(x,y)&#x3D;&#x3D;p[i1])。当i2!&#x3D;i1  在i2的集合中那gcd(x,y)&#x3D;&#x3D;p[i2],且p[i2]!&#x3D;p[i1],所以不可能一对(x,y)中多次被记录</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">#define int long long</span><br><span class="line"></span><br><span class="line">int primes[11000000];</span><br><span class="line">bool st[11000000];</span><br><span class="line">int pre[11000000];</span><br><span class="line">int cnt=0;</span><br><span class="line">void init(int k)&#123;</span><br><span class="line">    for(int i=2;i&lt;=k;i++)&#123;</span><br><span class="line">        if(!st[i])&#123;</span><br><span class="line">            primes[++cnt]=i;</span><br><span class="line">            pre[i]=i-1;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=1;j&lt;=cnt&amp;&amp;i*primes[j]&lt;=k;j++)&#123;</span><br><span class="line">            st[i*primes[j]]=1;</span><br><span class="line">            if(i%primes[j]==0)&#123;  pre[i*primes[j]]=pre[i]*primes[j]; break;&#125;</span><br><span class="line">            pre[i*primes[j]]=pre[i]*(primes[j]-1);</span><br><span class="line">        &#125;</span><br><span class="line">      pre[i]=pre[i-1]+pre[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    init(n);</span><br><span class="line">    int ans=0;</span><br><span class="line">    for(int i=1;i&lt;=cnt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=pre[n/primes[i]]&lt;&lt;1|1;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote></blockquote><p>所以呢就别不快乐。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.acwing.com/problem/content/222/&quot;&gt;220. 最大公约数 - AcWing题库&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;样例&quot;&gt;&lt;a href=&quot;#样例&quot; class=&quot;headerlink&quot; title=&quot;样例&quot;&gt;&lt;/a&gt;样例&lt;/h4&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入:4 输出:4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="数学" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="欧拉函数" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E6%95%B0%E5%AD%A6/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"/>
    
    
    <category term="题解" scheme="http://example.com/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="素数" scheme="http://example.com/tags/%E7%B4%A0%E6%95%B0/"/>
    
    <category term="数学" scheme="http://example.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="提高课" scheme="http://example.com/tags/%E6%8F%90%E9%AB%98%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>质数距离</title>
    <link href="http://example.com/2022/06/02/%E8%B4%A8%E6%95%B0%E8%B7%9D%E7%A6%BB/"/>
    <id>http://example.com/2022/06/02/%E8%B4%A8%E6%95%B0%E8%B7%9D%E7%A6%BB/</id>
    <published>2022-06-01T16:55:06.000Z</published>
    <updated>2022-06-01T18:06:50.321Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://www.acwing.com/problem/content/198/">196. 质数距离 - AcWing题库</a></p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 17</span><br><span class="line">14 17</span><br></pre></td></tr></table></figure><p>输出:</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2,3 are closest, 7,11 are most distant.</span><br><span class="line">There are no adjacent primes.</span><br></pre></td></tr></table></figure><hr><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>$$<br>如果是暴力的线性筛找一遍 2^{31}显然是不可取的，线性筛肯定会超时。l和r之间最多差10^{6}，那用试除法的话，<br>$$</p><p>$$<br>跑满复杂度也大概再10^{10}，那肯定也是会超时的。因此应该换一个思路，总所周知筛质素是去掉里面的合数剩下<br>$$</p><p>剩下的就是质数。我们也可以用同样的方法去掉l和r之间的所有的合数，然后就能得到所有的质数。<br>$$<br>一个合数x，它最小的质因子是小于等于\sqrt(x),因此我们只需要筛出1~\sqrt(r)的质数，然后再用再去掉是这些质<br>$$<br>因子的倍数的数即可。</p><p>求质数p大于等于x最小倍数公式：<br>$$<br>num&#x3D;(x+p-1)&#x2F;p;&#x2F;&#x2F;下取整 \\n<br>num&#x3D;x&#x2F;p;&#x2F;&#x2F;上取整<br>$$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(int i=1; i&lt;=cnt&amp;&amp;primes[i]&lt;=r; i++)&#123;//primes[i]是已经筛出来的的质因子</span><br><span class="line">    int p=primes[i];</span><br><span class="line">    for(int j=max(p*2,(l+p-1)/p*p); j&lt;=r; j+=p)&#123;//解释一下为什么是max(p*2,(l+p-1)/p),如果j等小于2*p也就是j等于p那j就是个质数所以我们不能给它做标记</span><br><span class="line">            st[j-l+1]=true;//把是这些质因子的倍数去掉</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述代码中的j-l+1是处理把它压缩大于等于l的第几个数，这样可以节省空间再1e6内</p><p>也就是我们存的每个素数它都要减去L加1；</p><p>处理完之后暴力找答案就可以了</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define int long long</span><br><span class="line">int primes[1000000],cnt;</span><br><span class="line">bool st[1100000];</span><br><span class="line">void init(int k)</span><br><span class="line">&#123;</span><br><span class="line">    cnt=0;</span><br><span class="line">    for(int i=2; i&lt;=k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!st[i])primes[++cnt]=i;</span><br><span class="line">        for(int j=1; j&lt;=cnt&amp;&amp;i*primes[j]&lt;=k; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            st[i*primes[j]]=true;</span><br><span class="line">            if(i%primes[j]==0) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">signed main()</span><br><span class="line">&#123;</span><br><span class="line">    int l,r;</span><br><span class="line">    while(cin&gt;&gt;l&gt;&gt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        memset(st,0,sizeof st);</span><br><span class="line">        init(1000000);</span><br><span class="line">        memset(st,0,sizeof st);</span><br><span class="line">        if(l==1)st[1]=1;</span><br><span class="line">        for(int i=1; i&lt;=cnt&amp;&amp;primes[i]&lt;=r; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int p=primes[i];</span><br><span class="line">            for(int j=max(p*2,(l+p-1)/p*p); j&lt;=r; j+=p)</span><br><span class="line">            &#123;</span><br><span class="line">                st[j-l+1]=true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt=0;</span><br><span class="line">        for(int i=1; i&lt;=r-l+1; i++)</span><br><span class="line">            if(!st[i])primes[++cnt]=i;</span><br><span class="line">        if(cnt&lt;=1) puts(&quot;There are no adjacent primes.&quot;);</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            int mi=9999999999,ma=0,di=0,da=0;</span><br><span class="line">            for(int i=2; i&lt;=cnt; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(primes[i]-primes[i-1]&gt;ma)</span><br><span class="line">                &#123;</span><br><span class="line">                    da=i;</span><br><span class="line">                    ma=primes[i]-primes[i-1];</span><br><span class="line">                &#125;</span><br><span class="line">                if(primes[i]-primes[i-1]&lt;mi)</span><br><span class="line">                &#123;</span><br><span class="line">                    di=i;</span><br><span class="line">                    mi=primes[i]-primes[i-1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            printf(&quot;%d,%d are closest, %d,%d are most distant.\n&quot;,primes[di-1]+l-1,primes[di]+l-1,primes[da-1]+l-1,primes[da]+l-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>所以呢就别不快乐。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.acwing.com/problem/content/198/&quot;&gt;196. 质数距离 - AcWing题库&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;样例&quot;&gt;&lt;a href=&quot;#样例&quot; class=&quot;headerlink&quot; title=&quot;样例&quot;&gt;&lt;/a&gt;样例&lt;/h4&gt;&lt;p&gt;输入：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;2 17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14 17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;输出:&lt;/p&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="数学" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="筛质数" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E6%95%B0%E5%AD%A6/%E7%AD%9B%E8%B4%A8%E6%95%B0/"/>
    
    
    <category term="题解" scheme="http://example.com/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="素数" scheme="http://example.com/tags/%E7%B4%A0%E6%95%B0/"/>
    
    <category term="数学" scheme="http://example.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="提高课" scheme="http://example.com/tags/%E6%8F%90%E9%AB%98%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>Hankson的趣味题</title>
    <link href="http://example.com/2022/06/02/Hankson%E7%9A%84%E8%B6%A3%E5%91%B3%E9%A2%98/"/>
    <id>http://example.com/2022/06/02/Hankson%E7%9A%84%E8%B6%A3%E5%91%B3%E9%A2%98/</id>
    <published>2022-06-01T16:52:21.000Z</published>
    <updated>2022-06-01T18:06:45.618Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>现在给了a0,a1,b0,b1四个数，问有多少个x满足 gcd(a0,x)&#x3D;a1,lcm(x,b0)&#x3D;b1;</p><span id="more"></span><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">41 1 96 288</span><br><span class="line">95 1 37 1776</span><br></pre></td></tr></table></figure><p>输出:6 2</p><hr><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>由于b1是lcm(x,b0) 那必然x就是b1的约数，所以只要枚举出所有的b1的约束，满足条件的就是x</p><p>那如何求b1的约数呢，如果是单纯的暴力那肯定是超时的。</p><p>但是我们可以记录所有b1的质因子并且每个质因子的个数，来达到因式分解的目的；<br>（线性筛的板子写假了 primes写成了bool类型 每个质数都是1抽了一晚的烟都没看出来哪里超时了）</p><pre><code>for(int i=1;primes[i]*primes[i]&lt;=h&amp;&amp;i&lt;=cnt;i++)&#123;    int s=0;    while(h%primes[i]==0) s++,h/=primes[i];    if(s!=0)in[++cntd]=&#123;primes[i],s&#125;;&#125;</code></pre><p>然后再根据质因子以及每个质因子的个数深搜枚举即可</p><p>dfs(1,1);&#x2F;&#x2F;深搜入口，第1个质因子，当前的值为1</p><p>深搜的过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void dfs(int u,int k)&#123;</span><br><span class="line">    if(u&gt;cntd) &#123;ans[++cntf]=k;return ;&#125;//如果记录的所有质因子都遍历完那就结束</span><br><span class="line">    for(int i=0;i&lt;=in[u].second;i++)&#123;</span><br><span class="line">        dfs(u+1,k);</span><br><span class="line">        k*=in[u].first;//枚举每个因子的数量</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define PII pair&lt;int,int&gt;</span><br><span class="line">int  cnt=0;</span><br><span class="line">bool st[100010];</span><br><span class="line">int primes[100010];</span><br><span class="line">PII in[100010];</span><br><span class="line">int num[100010];</span><br><span class="line">void init(int k)&#123;</span><br><span class="line">    for(int i=2;i&lt;=k;i++)&#123;</span><br><span class="line">        if(!st[i])primes[++cnt]=i;</span><br><span class="line">        for(int j=1;i*primes[j]&lt;=k&amp;&amp;j&lt;=cnt;j++)&#123;</span><br><span class="line">            st[i*primes[j]]=1;</span><br><span class="line">            if(i%primes[j]==0) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">int ans[1000100];</span><br><span class="line"> int cntd=0,cntf=0;</span><br><span class="line"></span><br><span class="line">void dfs(int u,int k)&#123;</span><br><span class="line">    if(u&gt;cntd) &#123;ans[++cntf]=k;return ;&#125;</span><br><span class="line">    for(int i=0;i&lt;=in[u].second;i++)&#123;</span><br><span class="line">        dfs(u+1,k);</span><br><span class="line">        k*=in[u].first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    int a0,a1,b0,b1;</span><br><span class="line">    cin&gt;&gt;a0&gt;&gt;a1&gt;&gt;b0&gt;&gt;b1;</span><br><span class="line">    cntd=0,cntf=0;</span><br><span class="line">    int h=b1;</span><br><span class="line">    for(int i=1;primes[i]*primes[i]&lt;=b1&amp;&amp;i&lt;=cnt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int s=0;</span><br><span class="line">        while(h%primes[i]==0) s++,h/=primes[i];</span><br><span class="line">        if(s!=0)in[++cntd]=&#123;primes[i],s&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    if(h&gt;1)in[++cntd]=&#123;h,1&#125;;</span><br><span class="line">    dfs(1,1);</span><br><span class="line">    int res=0;</span><br><span class="line">    //cout&lt;&lt;cntf&lt;&lt;&quot;+++&quot;;</span><br><span class="line">    for(int i=1;i&lt;=cntf;i++)&#123;</span><br><span class="line">        if(__gcd(ans[i],a0)==a1&amp;&amp;(long long)ans[i]*b0/__gcd(ans[i],b0)==b1)</span><br><span class="line">        res++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    init(100000);</span><br><span class="line">    int _;</span><br><span class="line">    cin&gt;&gt;_;</span><br><span class="line">    while(_--)&#123;</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote></blockquote><p>所以呢就不快乐。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;现在给了a0,a1,b0,b1四个数，问有多少个x满足 gcd(a0,x)&amp;#x3D;a1,lcm(x,b0)&amp;#x3D;b1;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="数学" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="约数个数" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E6%95%B0%E5%AD%A6/%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0/"/>
    
    
    <category term="题解" scheme="http://example.com/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="素数" scheme="http://example.com/tags/%E7%B4%A0%E6%95%B0/"/>
    
    <category term="数学" scheme="http://example.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="提高课" scheme="http://example.com/tags/%E6%8F%90%E9%AB%98%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>多重背包究极版--单调队列优化</title>
    <link href="http://example.com/2022/06/02/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E7%A9%B6%E6%9E%81%E7%89%88-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2022/06/02/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E7%A9%B6%E6%9E%81%E7%89%88-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96/</id>
    <published>2022-06-01T16:49:33.000Z</published>
    <updated>2022-06-01T18:06:56.297Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>题面不多说 多重背包</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 2 3</span><br><span class="line">2 4 1</span><br><span class="line">3 4 3</span><br><span class="line">4 5 2</span><br></pre></td></tr></table></figure><p>输出 10</p><span id="more"></span><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>如果把每种物品拆分成一个 当作01背包来处理 O（n * w *s）</p><p>二进制优化 O(n* w *log c)</p><p>单挑队列优化O(n * w)  （差不多线性的了终极版）</p><p>不了解但单挑队列优化（滑动窗口）的同学可以先学习这题<a href="https://www.acwing.com/activity/content/problem/content/1458/">AcWing 135. 最大子序和 - AcWing</a></p><p>简单的多重背包  二维表示 d [i][j]表示 在体积j下 并且可以装第i种物品 最多能获得多大价值</p><p>然后这个显然 可以化成一维  加上滚动数组</p><p>假设 gn是上个状态的结果 （也是上述说的dp[i][j]） 然后 dp[j]表示当前状态下得到的结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line"></span><br><span class="line">&#123;for(int j=1;j&lt;=m;j++) </span><br><span class="line"></span><br><span class="line">dp[j]=max&#123;gn[i-v]+w,gn[i-2v]+2w, gn[i-3v]+3w ...gn[i-kv]+kw&#125; k为min(j/v,s)也就是 在j最多能包含多少个第i个物品，这一步为毛要用gn而不是dp（这个dp是数组不是指算法）呢？因为如果用的是dp的话就变成了01完全背包。</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设同学你已经掌握了 滑动窗口的原理</p><p>我们发现 上述的这个循环有部分变量一直在重复</p><p>for(int j&#x3D;1;j&lt;&#x3D;m;j++) </p><pre><code>    dp[j]=max&#123;gn[i-v]+w,gn[i-2v]+2w, gn[i-3v]+3w ...gn[i-kv]+kw&#125; k为min(j/v,s)</code></pre><p>我们把这个循环拆开</p><p>首先 对于每一个物品的v循环 我们把它分为v类 每个j%v的值为一类</p><p>假设这个v为3(为什么是3，因为方便我码字)下面是拆开的部分</p><p>第一部分j%v&#x3D;&#x3D;0  dp[j]&#x3D;max{gn[0]+(j-0)&#x2F;v * w ,gn[v]+(j-v)&#x2F;v*w, gn[2v]+(j-2v) * w ,….gn[j-v]+w,gn[j] } </p><p>第二部分 j%v&#x3D;&#x3D;1  dp[j]&#x3D;max{gn[1]+(j-1)&#x2F;v * w ,gn[v+1]+(j-v-1)&#x2F;v*w, gn[2v+1]+(j-2v-1) * w ,….gn[j-v]+w,gn[j] } </p><p>第三部分 j%v&#x3D;&#x3D;2  dp[j]&#x3D;max{gn[2]+(j-2)&#x2F;v * w ,gn[v+2]+(j-v-2)&#x2F;v*w, gn[2v+2]+(j-2v-2) * w ,….gn[j-v]+w,gn[j] } </p><p>注意上面有不严谨的地方如果(j-xv)&#x2F;v&lt;s（x是自由变量 0，1，2。。。） 那是不够减的 所以要滑动窗口维护能减的数量下的最大值</p><p>同时我们把每个dp[j]的过程拆分一下<br>dp[j]    &#x3D;     dp[j]<br>dp[j+v]  &#x3D; max{dp[j] +  w,  dp[j+v]}<br>dp[j+2v] &#x3D; max{dp[j] + 2w,  dp[j+v]+  w, dp[j+2v]}<br>dp[j+3v] &#x3D; max{dp[j] + 3w,  dp[j+v] + 2w, dp[j+2v] + w, dp[j+3v]}<br>…<br>但是，这个队列中前面的数，每次都会增加一个 w ，</p><p>所以我们只需要记录 gn[k-f]+(k-f)&#x2F;v*w的最大值即可 由于 k-f+(k-f)&#x2F;v*w可以求出 所以记录 最大gn[k-f]即可</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;`</span><br><span class="line">`//#include &lt;algorithm&gt;`</span><br><span class="line">`#include &lt;cstring&gt;`</span><br><span class="line">`using namespace std;`</span><br><span class="line"></span><br><span class="line">`int que[100000],dp[100000],gn[100000];//队列，结果 ，工具队列`</span><br><span class="line"></span><br><span class="line">`signed main()`</span><br><span class="line">`&#123;`</span><br><span class="line">    `int n,m;`</span><br><span class="line">    `cin&gt;&gt;n&gt;&gt;m;`</span><br><span class="line">    `for(int i=1; i&lt;=n; i++)`</span><br><span class="line">    `&#123;`</span><br><span class="line">        `int v,w,s;`</span><br><span class="line">        `scanf(&quot;%d%d%d&quot;,&amp;v,&amp;w,&amp;s);//体积 价值 数量`</span><br><span class="line">        `memcpy(gn,dp,sizeof dp);`</span><br><span class="line">        `for(int j=0; j&lt;v; j++)`</span><br><span class="line">        `&#123;`</span><br><span class="line">            `int hh=1,tt=0;`</span><br><span class="line">            `for(int k=j; k&lt;=m; k+=v)`</span><br><span class="line">            `&#123;`</span><br><span class="line">                `if(que[hh]+s*v&lt;k&amp;&amp;hh&lt;=tt) hh++;</span><br><span class="line">                while(tt&gt;=hh&amp;&amp;gn[k]&gt;=gn[que[tt]]+(k-que[tt])/v*w)tt--;`</span><br><span class="line">                `que[++tt]=k;`</span><br><span class="line">                `dp[k]=(k-que[hh])/v*w+gn[que[hh]];`</span><br><span class="line">            `&#125;`</span><br><span class="line">        `&#125;`</span><br><span class="line">    `&#125;`</span><br><span class="line">     cout&lt;&lt;dp[m]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>所以呢就别不快乐。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;题面不多说 多重背包&lt;/p&gt;
&lt;h4 id=&quot;样例&quot;&gt;&lt;a href=&quot;#样例&quot; class=&quot;headerlink&quot; title=&quot;样例&quot;&gt;&lt;/a&gt;样例&lt;/h4&gt;&lt;p&gt;输入&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;4 5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 2 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2 4 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3 4 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4 5 2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;输出 10&lt;/p&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="动态规划" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="背包" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85/"/>
    
    
    <category term="提高课" scheme="http://example.com/tags/%E6%8F%90%E9%AB%98%E8%AF%BE/"/>
    
    <category term="多重背包" scheme="http://example.com/tags/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/"/>
    
    <category term="单调队列" scheme="http://example.com/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>第一天--概率事件及其概率运算</title>
    <link href="http://example.com/2022/06/01/%E7%AC%AC%E4%B8%80%E5%A4%A9-%E6%A6%82%E7%8E%87%E4%BA%8B%E4%BB%B6%E5%8F%8A%E5%85%B6%E6%A6%82%E7%8E%87%E8%BF%90%E7%AE%97/"/>
    <id>http://example.com/2022/06/01/%E7%AC%AC%E4%B8%80%E5%A4%A9-%E6%A6%82%E7%8E%87%E4%BA%8B%E4%BB%B6%E5%8F%8A%E5%85%B6%E6%A6%82%E7%8E%87%E8%BF%90%E7%AE%97/</id>
    <published>2022-06-01T15:29:33.000Z</published>
    <updated>2022-06-01T18:04:45.647Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.acwing.com/media/article/image/2022/06/01/69408_1a7d0cb8e1-1.jpg" alt="1.jpg"> </p><span id="more"></span><p><img src="https://cdn.acwing.com/media/article/image/2022/06/01/69408_45640262e1-2.jpg" alt="2.jpg"><br><img src="https://cdn.acwing.com/media/article/image/2022/06/01/69408_48589e57e1-3.jpg" alt="3.jpg"><br><img src="https://cdn.acwing.com/media/article/image/2022/06/01/69408_56b2702ee1-4.jpg" alt="4.jpg"><br><img src="https://cdn.acwing.com/media/article/image/2022/06/01/69408_5b278b59e1-5.jpg" alt="5.jpg"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.acwing.com/media/article/image/2022/06/01/69408_1a7d0cb8e1-1.jpg&quot; alt=&quot;1.jpg&quot;&gt; &lt;/p&gt;</summary>
    
    
    
    <category term="数学" scheme="http://example.com/categories/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="概率论" scheme="http://example.com/categories/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
    <category term="学习打卡" scheme="http://example.com/categories/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA/%E5%AD%A6%E4%B9%A0%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="数学" scheme="http://example.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="概率论" scheme="http://example.com/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>反素数</title>
    <link href="http://example.com/2022/05/30/%E5%8F%8D%E7%B4%A0%E6%95%B0/"/>
    <id>http://example.com/2022/05/30/%E5%8F%8D%E7%B4%A0%E6%95%B0/</id>
    <published>2022-05-30T13:28:44.000Z</published>
    <updated>2022-06-01T18:06:54.878Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://www.acwing.com/solution/content/81166/">AcWing 198. 反素数 - AcWing</a></p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1000</span><br><span class="line">输出：840</span><br></pre></td></tr></table></figure><span id="more"></span><hr><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>1 如果一个数字m 它的质因子p1,p2,p3,p4,p5  它每个质因子的个数N1,N2,N3,N4,N5 那它的约数个数就为N1xN2xN3xN4xN5;<br>2 如果要是上面要使上述的m尽量的小，那它的每个质因子必然是紧挨着的，同时对应的质因子的N1&gt;&#x3D;N2&gt;&#x3D;N3&gt;&#x3D;N4&gt;&#x3D;N5<br>顺便说一下2∗3∗5∗7∗11∗13∗17∗19∗23∗29∗3&gt;2*10^9 所以代码里面的线性筛没必要，枚举就可以了<br>如果每个质因子都一样大 那很明显 我尽量的把每个质因子的数量分为两分同时然后质因子也尽量多，那约数个数也就是<br>指数级最大，但是事与愿违，质因子分的多，同时拆分出的最大质因子也会变得很大所以要深搜，找出一个最佳的分配方案</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int cnt=0;</span><br><span class="line">int primes[100000];</span><br><span class="line">bool st[1000000];</span><br><span class="line">int qmi(int a,int b)&#123;</span><br><span class="line">    int ans=1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1) ans*=a;</span><br><span class="line">        a*=a;</span><br><span class="line">    b&gt;&gt;=1;</span><br><span class="line">    &#125;return ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void init(int k)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=2; i&lt;=k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!st[i]) primes[++cnt]=i;</span><br><span class="line">        for(int j=1; j&lt;=cnt&amp;&amp;i*primes[j]&lt;=k; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            st[i*primes[j]]=1;</span><br><span class="line">            if(i%primes[j]==0)break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int mm=0;//最多约数的数量</span><br><span class="line">int n;</span><br><span class="line">int cc=999999;//递归找到当前状态下 出现最多约数的最小值</span><br><span class="line">void dfs(int num,int k,int f,int ans)</span><br><span class="line">&#123;</span><br><span class="line">    if(ans==mm)cc=min(cc,num);//如果当前约数的数量等于目前最大的约数数量 那cc（也就是答案）要取两者最小</span><br><span class="line">    else if(ans&gt;mm)&#123;//如果约数数量大于当前最大的 那就更新答案</span><br><span class="line">        mm=ans;</span><br><span class="line">        cc=num;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    for(int i=1;i&lt;=f;i++)//深搜下一个质因子</span><br><span class="line">    &#123;</span><br><span class="line">        int h=qmi(primes[k+1],i);//快速幂也没必要 我是小丑</span><br><span class="line">        if((long long)h*num&gt;n) break;//我的写法要加longlong 不然会爆</span><br><span class="line">         dfs(num*h,k+1,i,ans*(i+1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed main()</span><br><span class="line">&#123;</span><br><span class="line">    init(100010);</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=1; i&lt;=30; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(1&lt;&lt;i&gt;=n)break;</span><br><span class="line">        dfs(1&lt;&lt;i,1,i,i+1);//当前数值，多少个质数因子，最后一个数的次方，约数个数</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  cout&lt;&lt;cc&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>所以呢就别不快乐。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.acwing.com/solution/content/81166/&quot;&gt;AcWing 198. 反素数 - AcWing&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;样例&quot;&gt;&lt;a href=&quot;#样例&quot; class=&quot;headerlink&quot; title=&quot;样例&quot;&gt;&lt;/a&gt;样例&lt;/h4&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：1000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：840&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="算法题解" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    <category term="数学" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="约数个数" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/%E6%95%B0%E5%AD%A6/%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0/"/>
    
    
    <category term="题解" scheme="http://example.com/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="素数" scheme="http://example.com/tags/%E7%B4%A0%E6%95%B0/"/>
    
    <category term="数学" scheme="http://example.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="提高课" scheme="http://example.com/tags/%E6%8F%90%E9%AB%98%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>第一篇博客</title>
    <link href="http://example.com/2022/05/30/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>http://example.com/2022/05/30/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</id>
    <published>2022-05-30T13:01:20.000Z</published>
    <updated>2022-06-01T17:02:45.536Z</updated>
    
    <content type="html"><![CDATA[<p>#服了</p><p>这个老六博客搭载了一天。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;#服了&lt;/p&gt;
&lt;p&gt;这个老六博客搭载了一天。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="分享日常" scheme="http://example.com/categories/%E5%88%86%E4%BA%AB%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
</feed>
